# OptiX Ray Tracer Integration Guide

This document explains how to use the OptiX ray tracer with voxel datasets generated by the main pipeline.

## Overview

The `optix_raytracer/` module provides GPU-accelerated ray tracing for voxel occupancy grids. It's designed to work seamlessly with the voxel datasets produced by the main pipeline.

## What It Does

The ray tracer casts rays through voxel grids and **accumulates the total distance traveled through occupied voxels**. This is useful for:

- **Depth/thickness maps**: Measure material thickness from any viewpoint
- **X-ray style rendering**: Accumulate density along ray paths
- **Occlusion analysis**: Determine line-of-sight distances
- **Neural rendering**: Generate training data for transparency-aware models

## Quick Example

```python
import numpy as np
from pathlib import Path

# Add OptiX module to path (after building)
import sys
sys.path.insert(0, "optix_raytracer/build")

from optix_voxel_tracer import VoxelRayTracer

# Load voxel grid from your dataset
dataset_dir = Path("dataset")
voxels = np.load(dataset_dir / "objects/object_0001/level_0.npz")['voxels']

# Create ray tracer
tracer = VoxelRayTracer(voxels, voxel_size=1.0)

# Define orthographic rays from above
resolution = (512, 512)
origins = np.zeros((*resolution, 3), dtype=np.float32)
directions = np.zeros((*resolution, 3), dtype=np.float32)

for i in range(resolution[0]):
    for j in range(resolution[1]):
        x = (i / resolution[0]) * 2 - 1
        y = (j / resolution[1]) * 2 - 1
        origins[i, j] = [x, y, 2.0]      # Above object
        directions[i, j] = [0, 0, -1]    # Point down

# Trace rays - get accumulated distances
distances = tracer.trace_rays(origins, directions)

# Visualize
import matplotlib.pyplot as plt
plt.imshow(distances, cmap='viridis')
plt.colorbar(label='Distance through voxels')
plt.savefig('ray_trace.png')
```

## Integration with Dataset Pipeline

### Processing Entire Dataset

```python
from pathlib import Path
from voxel_dataset_generator import Config
from optix_voxel_tracer import VoxelRayTracer
import numpy as np

# Your dataset configuration
dataset_dir = Path("dataset")
config = Config(output_dir=dataset_dir)

# Process each object
objects_dir = dataset_dir / "objects"
output_dir = dataset_dir / "ray_traces"
output_dir.mkdir(exist_ok=True)

for obj_dir in sorted(objects_dir.iterdir()):
    if not obj_dir.is_dir():
        continue

    object_id = obj_dir.name.split('_')[1]
    voxel_file = obj_dir / "level_0.npz"

    if not voxel_file.exists():
        continue

    print(f"Processing object {object_id}...")

    # Load voxels
    voxels = np.load(voxel_file)['voxels']

    # Create tracer
    tracer = VoxelRayTracer(voxels)

    # Generate rays (customize as needed)
    origins, directions = generate_rays(...)

    # Trace
    distances = tracer.trace_rays(origins, directions)

    # Save results
    output_file = output_dir / f"object_{object_id}_rays.npz"
    np.savez_compressed(output_file, distances=distances)
```

### Multi-View Rendering

Generate training data from multiple viewpoints:

```python
def render_multi_view(voxel_file, num_views=8, resolution=(256, 256)):
    """Render object from multiple viewpoints."""
    voxels = np.load(voxel_file)['voxels']
    tracer = VoxelRayTracer(voxels)

    views = []
    for i in range(num_views):
        angle = 2 * np.pi * i / num_views

        # Camera on a circle
        camera_pos = [
            2.0 * np.cos(angle),
            2.0 * np.sin(angle),
            0.5
        ]

        # Generate perspective rays
        origins, directions = generate_perspective_rays(
            resolution, camera_pos, look_at=[0, 0, 0], up=[0, 0, 1]
        )

        # Trace
        distances = tracer.trace_rays(origins, directions)
        views.append(distances)

    return np.stack(views)

# Usage
views = render_multi_view("dataset/objects/object_0001/level_0.npz")
# views.shape: (8, 256, 256)
```

## Working with Hierarchical Data

The ray tracer can be used with any level of the octree hierarchy:

```python
# Trace at different resolutions
for level in range(5):
    # Note: You'll need to load subvolumes and reconstruct the grid
    # or trace individual subvolumes separately

    if level == 0:
        # Top level: load directly
        voxels = np.load(obj_dir / "level_0.npz")['voxels']
    else:
        # Load subvolumes and reconstruct
        # (implementation depends on your needs)
        voxels = load_level(obj_dir, level)

    tracer = VoxelRayTracer(voxels)
    distances = tracer.trace_rays(origins, directions)
```

## Use Cases

### 1. Depth Map Generation

Create depth maps for neural rendering:

```python
# Orthographic projection (parallel rays)
def create_depth_map(voxels, direction='z'):
    tracer = VoxelRayTracer(voxels)

    if direction == 'z':
        # Top-down view
        origins[..., 2] = 2.0
        directions[..., 2] = -1.0
    # ... other directions

    return tracer.trace_rays(origins, directions)
```

### 2. Material Thickness Analysis

Analyze structural properties:

```python
# Average thickness through object
distances = tracer.trace_rays(origins, directions)
mean_thickness = distances[distances > 0].mean()
max_thickness = distances.max()

print(f"Average thickness: {mean_thickness:.2f}")
print(f"Maximum thickness: {max_thickness:.2f}")
```

### 3. Occlusion Fields

Generate occlusion data for rendering:

```python
# Sample rays in all directions from surface points
# (useful for ambient occlusion, visibility, etc.)

def compute_occlusion_field(voxels, sample_points, num_samples=64):
    tracer = VoxelRayTracer(voxels)

    occlusion = []
    for point in sample_points:
        # Sample directions on hemisphere
        dirs = sample_hemisphere(num_samples)
        origins = np.tile(point, (num_samples, 1))

        distances = tracer.trace_rays(origins, dirs)
        occlusion.append(distances.mean())

    return np.array(occlusion)
```

### 4. Training Data for Neural Networks

```python
# Generate paired data: voxels + ray traces
def create_training_dataset(dataset_dir, output_dir):
    for obj_file in Path(dataset_dir).glob("objects/*/level_0.npz"):
        voxels = np.load(obj_file)['voxels']
        tracer = VoxelRayTracer(voxels)

        # Multiple random viewpoints
        for view_idx in range(10):
            camera_pos = random_sphere_point(radius=2.0)
            origins, directions = generate_perspective_rays(...)

            distances = tracer.trace_rays(origins, directions)

            # Save as training pair
            np.savez(
                output_dir / f"{obj_file.stem}_view_{view_idx}.npz",
                voxels=voxels,
                distances=distances,
                camera_pos=camera_pos
            )
```

## Performance Tips

### Batch Processing

Process multiple objects efficiently:

```python
# Reuse GPU context by keeping tracer alive
for voxel_file in voxel_files:
    voxels = np.load(voxel_file)['voxels']
    tracer = VoxelRayTracer(voxels)

    # Trace from multiple viewpoints with same tracer
    for view in views:
        distances = tracer.trace_rays(origins[view], directions[view])
        # ... save results
```

### Memory Management

For large datasets:

```python
# Process in chunks
chunk_size = 100
for chunk in chunks(voxel_files, chunk_size):
    for voxel_file in chunk:
        # Process
        pass
    # Cleanup between chunks
    gc.collect()
```

## Building and Installation

See `optix_raytracer/README.md` and `optix_raytracer/QUICKSTART.md` for:
- Prerequisites
- Build instructions
- Installation
- Troubleshooting

Quick build:
```bash
cd optix_raytracer
export OptiX_INSTALL_DIR=/path/to/optix
./build.sh
```

## Examples

The `optix_raytracer/examples/` directory contains:

- **basic_tracing.py**: Simple sphere example
- **render_dataset.py**: Render objects from your dataset
- **batch_process.py**: Batch process multiple objects

Run examples:
```bash
cd optix_raytracer/examples
export PYTHONPATH=../build:$PYTHONPATH
python3 render_dataset.py --dataset-dir ../../dataset --object-id 0001
```

## Architecture

The ray tracer uses:
- **OptiX 7**: NVIDIA's ray tracing API
- **DDA Algorithm**: Efficient voxel grid traversal
- **Distance Accumulation**: Sums path length through occupied voxels

Key difference from traditional rendering: Instead of stopping at first hit, rays continue through the entire object, accumulating distance traveled through solid voxels.

See `optix_raytracer/ARCHITECTURE.md` for technical details.

## Comparison with Other Approaches

| Method | Speed | Accuracy | Transparency Support |
|--------|-------|----------|---------------------|
| **OptiX (this)** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ Full |
| PyTorch3D | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⚠️ Limited |
| Open3D | ⭐⭐ | ⭐⭐⭐⭐ | ❌ No |
| NumPy CPU | ⭐ | ⭐⭐⭐⭐⭐ | ✅ Full |

## Future Extensions

Potential enhancements:
- Multi-resolution tracing using octree hierarchy
- Color/material accumulation
- Normal computation
- Sparse voxel octree (SVO) support
- Real-time interactive viewer

## Support

For issues with:
- **Building**: See `optix_raytracer/README.md` troubleshooting
- **Integration**: Check this document and examples
- **OptiX/CUDA**: Refer to NVIDIA documentation

## License

Same as parent project (MIT).
