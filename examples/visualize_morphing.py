#!/usr/bin/env python3
"""Visualize morphing sequences generated by optimal transport.

This script loads a morphing sequence and creates visualizations:
- 3D visualization using matplotlib
- Side-by-side comparison
- Animation (optional)
"""

import argparse
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from typing import List, Tuple


def load_morphing_sequence(output_dir: Path, source_id: str, target_id: str) -> List[np.ndarray]:
    """Load morphing sequence from disk.

    Args:
        output_dir: Directory containing morphing results
        source_id: Source object ID
        target_id: Target object ID

    Returns:
        List of voxel grids (D, H, W)
    """
    print(f"Loading morphing sequence from {output_dir}...")

    # Find all morphing files
    pattern = f"morph_{source_id}_to_{target_id}_step_*.npz"
    files = sorted(output_dir.glob(pattern))

    if not files:
        raise FileNotFoundError(f"No morphing files found matching: {pattern}")

    sequence = []
    for filepath in files:
        data = np.load(filepath)
        voxels = data['voxels']
        sequence.append(voxels)
        print(f"  Loaded {filepath.name}: shape={voxels.shape}, "
              f"occupancy={voxels.mean():.2%}")

    return sequence


def visualize_voxel_grid_3d(
    voxels: np.ndarray,
    ax: plt.Axes,
    title: str = "",
    alpha: float = 0.3,
    color: str = 'blue',
):
    """Visualize a single voxel grid in 3D.

    Args:
        voxels: (D, H, W) voxel grid
        ax: Matplotlib 3D axes
        title: Plot title
        alpha: Transparency
        color: Voxel color
    """
    # Get occupied voxel coordinates
    occupied = np.where(voxels > 0.5)
    z, y, x = occupied  # Note: numpy indexing is (D, H, W) but plot as (x, y, z)

    if len(x) == 0:
        ax.text(0.5, 0.5, 0.5, 'Empty', ha='center', va='center')
        return

    # Create voxel plot
    ax.scatter(x, y, z, c=color, alpha=alpha, s=1, marker='s')

    # Set labels and title
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title(title)

    # Set equal aspect ratio
    max_dim = max(voxels.shape)
    ax.set_xlim([0, max_dim])
    ax.set_ylim([0, max_dim])
    ax.set_zlim([0, max_dim])

    # Set viewing angle
    ax.view_init(elev=20, azim=45)


def create_grid_visualization(
    sequence: List[np.ndarray],
    num_cols: int = 5,
    figsize: Tuple[int, int] = (20, 12),
    output_file: Optional[Path] = None,
):
    """Create grid visualization of morphing sequence.

    Args:
        sequence: List of voxel grids
        num_cols: Number of columns in grid
        figsize: Figure size
        output_file: Optional output file path
    """
    num_steps = len(sequence)
    num_rows = (num_steps + num_cols - 1) // num_cols

    fig = plt.figure(figsize=figsize)

    for i, voxels in enumerate(sequence):
        ax = fig.add_subplot(num_rows, num_cols, i + 1, projection='3d')

        t = i / (num_steps - 1) if num_steps > 1 else 0
        color = plt.cm.viridis(t)  # Color gradient from source to target

        visualize_voxel_grid_3d(
            voxels,
            ax,
            title=f"t={t:.2f}",
            alpha=0.3,
            color=color,
        )

    plt.tight_layout()

    if output_file:
        plt.savefig(output_file, dpi=150, bbox_inches='tight')
        print(f"Saved visualization to {output_file}")
    else:
        plt.show()


def create_comparison_slices(
    sequence: List[np.ndarray],
    slice_indices: List[int],
    slice_axis: int = 0,
    figsize: Tuple[int, int] = (20, 10),
    output_file: Optional[Path] = None,
):
    """Create 2D slice comparison across morphing sequence.

    Args:
        sequence: List of voxel grids
        slice_indices: Indices of slices to visualize along axis
        slice_axis: Axis to slice along (0=D, 1=H, 2=W)
        figsize: Figure size
        output_file: Optional output file path
    """
    num_steps = len(sequence)
    num_slices = len(slice_indices)

    fig, axes = plt.subplots(num_slices, num_steps, figsize=figsize)
    if num_slices == 1:
        axes = axes.reshape(1, -1)
    if num_steps == 1:
        axes = axes.reshape(-1, 1)

    for i, voxels in enumerate(sequence):
        t = i / (num_steps - 1) if num_steps > 1 else 0

        for j, slice_idx in enumerate(slice_indices):
            ax = axes[j, i]

            # Extract slice
            if slice_axis == 0:
                slice_2d = voxels[slice_idx, :, :]
            elif slice_axis == 1:
                slice_2d = voxels[:, slice_idx, :]
            else:  # slice_axis == 2
                slice_2d = voxels[:, :, slice_idx]

            # Plot
            ax.imshow(slice_2d, cmap='binary', origin='lower')
            ax.axis('off')

            if j == 0:
                ax.set_title(f"t={t:.2f}", fontsize=10)
            if i == 0:
                ax.set_ylabel(f"Slice {slice_idx}", fontsize=10)

    plt.tight_layout()

    if output_file:
        plt.savefig(output_file, dpi=150, bbox_inches='tight')
        print(f"Saved slice comparison to {output_file}")
    else:
        plt.show()


def create_occupancy_plot(
    sequence: List[np.ndarray],
    output_file: Optional[Path] = None,
):
    """Plot occupancy ratio across morphing sequence.

    Args:
        sequence: List of voxel grids
        output_file: Optional output file path
    """
    occupancies = [voxels.mean() for voxels in sequence]
    t_values = np.linspace(0, 1, len(sequence))

    plt.figure(figsize=(10, 6))
    plt.plot(t_values, occupancies, 'o-', linewidth=2, markersize=8)
    plt.xlabel('Interpolation parameter t', fontsize=12)
    plt.ylabel('Voxel occupancy ratio', fontsize=12)
    plt.title('Occupancy along morphing trajectory', fontsize=14)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()

    if output_file:
        plt.savefig(output_file, dpi=150, bbox_inches='tight')
        print(f"Saved occupancy plot to {output_file}")
    else:
        plt.show()


def create_volume_histogram(
    sequence: List[np.ndarray],
    output_file: Optional[Path] = None,
):
    """Create histogram of voxel counts across sequence.

    Args:
        sequence: List of voxel grids
        output_file: Optional output file path
    """
    voxel_counts = [int(voxels.sum()) for voxels in sequence]
    t_values = np.linspace(0, 1, len(sequence))

    plt.figure(figsize=(10, 6))
    plt.bar(t_values, voxel_counts, width=0.8/(len(sequence)-1) if len(sequence) > 1 else 0.1)
    plt.xlabel('Interpolation parameter t', fontsize=12)
    plt.ylabel('Number of occupied voxels', fontsize=12)
    plt.title('Occupied voxel count along trajectory', fontsize=14)
    plt.grid(True, alpha=0.3, axis='y')
    plt.tight_layout()

    if output_file:
        plt.savefig(output_file, dpi=150, bbox_inches='tight')
        print(f"Saved volume histogram to {output_file}")
    else:
        plt.show()


def main():
    parser = argparse.ArgumentParser(
        description="Visualize optimal transport morphing sequences"
    )
    parser.add_argument(
        '--input-dir',
        type=Path,
        default=Path('morphing_results'),
        help='Input directory containing morphing sequence'
    )
    parser.add_argument(
        '--source-id',
        type=str,
        required=True,
        help='Source object ID'
    )
    parser.add_argument(
        '--target-id',
        type=str,
        required=True,
        help='Target object ID'
    )
    parser.add_argument(
        '--output-dir',
        type=Path,
        default=None,
        help='Output directory for visualizations (if not set, show interactively)'
    )
    parser.add_argument(
        '--num-cols',
        type=int,
        default=5,
        help='Number of columns in grid visualization'
    )
    parser.add_argument(
        '--slice-axis',
        type=int,
        choices=[0, 1, 2],
        default=0,
        help='Axis for slice visualization (0=Z, 1=Y, 2=X)'
    )

    args = parser.parse_args()

    print("=" * 70)
    print("Morphing Sequence Visualization")
    print("=" * 70)

    # Load sequence
    sequence = load_morphing_sequence(
        args.input_dir,
        args.source_id,
        args.target_id,
    )

    # Prepare output paths
    if args.output_dir:
        args.output_dir.mkdir(parents=True, exist_ok=True)
        prefix = f"morph_{args.source_id}_to_{args.target_id}"
        grid_file = args.output_dir / f"{prefix}_grid.png"
        slices_file = args.output_dir / f"{prefix}_slices.png"
        occupancy_file = args.output_dir / f"{prefix}_occupancy.png"
        volume_file = args.output_dir / f"{prefix}_volume.png"
    else:
        grid_file = slices_file = occupancy_file = volume_file = None

    # Create visualizations
    print("\nCreating 3D grid visualization...")
    create_grid_visualization(
        sequence,
        num_cols=args.num_cols,
        output_file=grid_file,
    )

    print("\nCreating slice comparison...")
    # Use 3 evenly spaced slices
    grid_shape = sequence[0].shape
    slice_dim = grid_shape[args.slice_axis]
    slice_indices = [slice_dim // 4, slice_dim // 2, 3 * slice_dim // 4]

    create_comparison_slices(
        sequence,
        slice_indices=slice_indices,
        slice_axis=args.slice_axis,
        output_file=slices_file,
    )

    print("\nCreating occupancy plot...")
    create_occupancy_plot(sequence, output_file=occupancy_file)

    print("\nCreating volume histogram...")
    create_volume_histogram(sequence, output_file=volume_file)

    print("\n" + "=" * 70)
    print("Visualization complete!")
    if args.output_dir:
        print(f"Results saved to: {args.output_dir}")
    print("=" * 70)


if __name__ == '__main__':
    main()
