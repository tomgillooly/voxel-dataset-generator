#!/usr/bin/env python3
"""Visualize light transport ground truth datasets.

This script provides various visualization tools for transfer matrices
and light transport data generated by the light transport pipeline.

Usage:
    # View a single transfer matrix
    python visualize_light_transport.py matrix path/to/transfer.npz

    # Compare multiple transfer matrices
    python visualize_light_transport.py compare file1.npz file2.npz

    # Analyze a dataset directory
    python visualize_light_transport.py analyze path/to/dataset/

    # Interactive exploration (requires plotly)
    python visualize_light_transport.py interactive path/to/transfer.npz
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Optional, List, Tuple

import numpy as np

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))


def load_transfer_data(path: Path) -> Tuple[np.ndarray, dict]:
    """Load transfer matrix and metadata from npz file."""
    data = np.load(path, allow_pickle=True)
    transfer = data['transfer_matrix']

    # Reconstruct metadata
    metadata = {}
    for key in data.files:
        if key == 'transfer_matrix':
            continue
        val = data[key]
        if isinstance(val, np.ndarray):
            if val.ndim == 0:
                val = val.item()
            elif val.size == 1:
                val = val.item()
            else:
                val = val.tolist()
        metadata[key] = val

    return transfer, metadata


def plot_transfer_matrix(
    transfer: np.ndarray,
    title: str = "Transfer Matrix",
    output_path: Optional[Path] = None,
    log_scale: bool = True,
    cmap: str = 'viridis',
    figsize: Tuple[int, int] = (12, 10)
):
    """Plot transfer matrix as a heatmap."""
    import matplotlib.pyplot as plt

    fig, ax = plt.subplots(figsize=figsize)

    data = np.abs(transfer)
    if log_scale:
        data = np.log10(data + 1e-10)
        label = "log₁₀(|T|)"
    else:
        label = "|T|"

    im = ax.imshow(data, cmap=cmap, aspect='equal')
    cbar = plt.colorbar(im, ax=ax, label=label, shrink=0.8)

    ax.set_xlabel("Incident condition (patch × SH)")
    ax.set_ylabel("Exitant condition (patch × SH)")
    ax.set_title(title)

    # Add grid lines for patch boundaries if matrix is small enough
    n = transfer.shape[0]
    if n <= 500:
        # Assume 9 SH coefficients per patch
        n_sh = 9
        if n % n_sh == 0:
            n_patches = n // n_sh
            for i in range(1, n_patches):
                ax.axhline(i * n_sh - 0.5, color='white', linewidth=0.3, alpha=0.5)
                ax.axvline(i * n_sh - 0.5, color='white', linewidth=0.3, alpha=0.5)

    plt.tight_layout()

    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved to {output_path}")
        plt.close()
    else:
        plt.show()


def plot_transfer_statistics(
    transfer: np.ndarray,
    metadata: dict,
    output_path: Optional[Path] = None
):
    """Plot various statistics about the transfer matrix."""
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 3, figsize=(15, 10))

    # 1. Value histogram
    ax = axes[0, 0]
    values = transfer.flatten()
    values = values[values != 0]  # Remove zeros
    if len(values) > 0:
        ax.hist(np.log10(np.abs(values) + 1e-10), bins=50, edgecolor='black', alpha=0.7)
        ax.set_xlabel("log₁₀(|value|)")
        ax.set_ylabel("Count")
        ax.set_title("Value Distribution (non-zero)")

    # 2. Column sums (energy per incident condition)
    ax = axes[0, 1]
    col_sums = np.abs(transfer).sum(axis=0)
    ax.plot(col_sums, linewidth=0.5)
    ax.axhline(col_sums.mean(), color='red', linestyle='--', label=f'Mean: {col_sums.mean():.4f}')
    ax.set_xlabel("Incident condition")
    ax.set_ylabel("Column sum")
    ax.set_title("Energy Conservation (column sums)")
    ax.legend()

    # 3. Row sums (sensitivity per exitant condition)
    ax = axes[0, 2]
    row_sums = np.abs(transfer).sum(axis=1)
    ax.plot(row_sums, linewidth=0.5)
    ax.axhline(row_sums.mean(), color='red', linestyle='--', label=f'Mean: {row_sums.mean():.4f}')
    ax.set_xlabel("Exitant condition")
    ax.set_ylabel("Row sum")
    ax.set_title("Sensitivity (row sums)")
    ax.legend()

    # 4. Diagonal vs off-diagonal
    ax = axes[1, 0]
    n = transfer.shape[0]
    diagonal = np.abs(np.diag(transfer))
    off_diag_mask = ~np.eye(n, dtype=bool)
    off_diagonal = np.abs(transfer[off_diag_mask])

    ax.hist(np.log10(diagonal + 1e-10), bins=30, alpha=0.7, label='Diagonal', density=True)
    if len(off_diagonal) > 0:
        # Sample for speed
        sample = off_diagonal[off_diagonal > 0]
        if len(sample) > 10000:
            sample = np.random.choice(sample, 10000, replace=False)
        if len(sample) > 0:
            ax.hist(np.log10(sample + 1e-10), bins=30, alpha=0.7, label='Off-diagonal', density=True)
    ax.set_xlabel("log₁₀(|value|)")
    ax.set_ylabel("Density")
    ax.set_title("Diagonal vs Off-diagonal")
    ax.legend()

    # 5. Sparsity pattern
    ax = axes[1, 1]
    threshold = np.abs(transfer).max() * 1e-6
    sparsity = (np.abs(transfer) > threshold).astype(float)
    ax.imshow(sparsity, cmap='binary', aspect='equal')
    ax.set_xlabel("Incident condition")
    ax.set_ylabel("Exitant condition")
    nnz_ratio = sparsity.sum() / sparsity.size
    ax.set_title(f"Sparsity Pattern ({100*nnz_ratio:.1f}% non-zero)")

    # 6. Per-face analysis
    ax = axes[1, 2]
    n_sh = metadata.get('n_sh', 9)
    patches_per_face = metadata.get('patches_per_face', 8)
    patches_per_face_sq = patches_per_face ** 2

    if n_sh * patches_per_face_sq * 6 == n:
        face_names = ['+X', '-X', '+Y', '-Y', '+Z', '-Z']
        face_energies = []
        for face in range(6):
            start = face * patches_per_face_sq * n_sh
            end = (face + 1) * patches_per_face_sq * n_sh
            face_energy = np.abs(transfer[:, start:end]).sum()
            face_energies.append(face_energy)

        ax.bar(face_names, face_energies, edgecolor='black')
        ax.set_xlabel("Face")
        ax.set_ylabel("Total energy")
        ax.set_title("Energy by Incident Face")
    else:
        ax.text(0.5, 0.5, "Face analysis not available", ha='center', va='center')
        ax.set_title("Face Analysis")

    plt.suptitle(f"Transfer Matrix Statistics\n{metadata.get('source_file', 'Unknown source')}", y=1.02)
    plt.tight_layout()

    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved to {output_path}")
        plt.close()
    else:
        plt.show()


def plot_face_to_face_transport(
    transfer: np.ndarray,
    metadata: dict,
    output_path: Optional[Path] = None
):
    """Plot face-to-face transport matrix (6x6 summary)."""
    import matplotlib.pyplot as plt

    n_sh = metadata.get('n_sh', 9)
    patches_per_face = metadata.get('patches_per_face', 8)
    patches_per_face_sq = patches_per_face ** 2
    n_per_face = patches_per_face_sq * n_sh

    n = transfer.shape[0]
    if n_per_face * 6 != n:
        print("Cannot compute face-to-face transport: dimensions don't match")
        return

    # Compute 6x6 face-to-face transport
    face_transport = np.zeros((6, 6))
    for i_face in range(6):
        for o_face in range(6):
            i_start = i_face * n_per_face
            i_end = (i_face + 1) * n_per_face
            o_start = o_face * n_per_face
            o_end = (o_face + 1) * n_per_face
            face_transport[o_face, i_face] = np.abs(transfer[o_start:o_end, i_start:i_end]).sum()

    # Normalize by incident energy
    col_sums = face_transport.sum(axis=0, keepdims=True)
    col_sums[col_sums == 0] = 1
    face_transport_norm = face_transport / col_sums

    fig, axes = plt.subplots(1, 2, figsize=(14, 6))

    face_names = ['+X', '-X', '+Y', '-Y', '+Z', '-Z']

    # Raw transport
    ax = axes[0]
    im = ax.imshow(face_transport, cmap='YlOrRd')
    ax.set_xticks(range(6))
    ax.set_yticks(range(6))
    ax.set_xticklabels(face_names)
    ax.set_yticklabels(face_names)
    ax.set_xlabel("Incident Face")
    ax.set_ylabel("Exitant Face")
    ax.set_title("Face-to-Face Transport (Total)")
    plt.colorbar(im, ax=ax, shrink=0.8)

    # Add text annotations
    for i in range(6):
        for j in range(6):
            val = face_transport[i, j]
            ax.text(j, i, f'{val:.2e}', ha='center', va='center',
                   fontsize=8, color='white' if val > face_transport.max()/2 else 'black')

    # Normalized transport
    ax = axes[1]
    im = ax.imshow(face_transport_norm, cmap='YlOrRd', vmin=0, vmax=1)
    ax.set_xticks(range(6))
    ax.set_yticks(range(6))
    ax.set_xticklabels(face_names)
    ax.set_yticklabels(face_names)
    ax.set_xlabel("Incident Face")
    ax.set_ylabel("Exitant Face")
    ax.set_title("Face-to-Face Transport (Normalized)")
    plt.colorbar(im, ax=ax, shrink=0.8, label="Fraction")

    # Add text annotations
    for i in range(6):
        for j in range(6):
            val = face_transport_norm[i, j]
            ax.text(j, i, f'{val:.2f}', ha='center', va='center',
                   fontsize=9, color='white' if val > 0.5 else 'black')

    plt.suptitle("Face-to-Face Light Transport", y=1.02)
    plt.tight_layout()

    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved to {output_path}")
        plt.close()
    else:
        plt.show()


def plot_sh_mode_transport(
    transfer: np.ndarray,
    metadata: dict,
    output_path: Optional[Path] = None
):
    """Plot SH mode to SH mode transport (9x9 summary)."""
    import matplotlib.pyplot as plt

    n_sh = metadata.get('n_sh', 9)
    n_patches = metadata.get('n_patches', 384)

    n = transfer.shape[0]
    if n_sh * n_patches != n:
        print("Cannot compute SH mode transport: dimensions don't match")
        return

    # Compute 9x9 SH-to-SH transport
    sh_transport = np.zeros((n_sh, n_sh))
    for i_sh in range(n_sh):
        for o_sh in range(n_sh):
            total = 0
            for patch in range(n_patches):
                i_idx = patch * n_sh + i_sh
                o_idx = patch * n_sh + o_sh
                # Sum over all patch combinations
                for p2 in range(n_patches):
                    total += np.abs(transfer[p2 * n_sh + o_sh, patch * n_sh + i_sh])
            sh_transport[o_sh, i_sh] = total

    fig, ax = plt.subplots(figsize=(8, 7))

    im = ax.imshow(sh_transport, cmap='plasma')
    ax.set_xlabel("Incident SH mode")
    ax.set_ylabel("Exitant SH mode")
    ax.set_title("SH Mode Coupling")

    # SH mode labels
    sh_labels = ['Y₀⁰', 'Y₁⁻¹', 'Y₁⁰', 'Y₁¹', 'Y₂⁻²', 'Y₂⁻¹', 'Y₂⁰', 'Y₂¹', 'Y₂²']
    if n_sh <= len(sh_labels):
        ax.set_xticks(range(n_sh))
        ax.set_yticks(range(n_sh))
        ax.set_xticklabels(sh_labels[:n_sh])
        ax.set_yticklabels(sh_labels[:n_sh])

    plt.colorbar(im, ax=ax, shrink=0.8, label="Total transport")
    plt.tight_layout()

    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved to {output_path}")
        plt.close()
    else:
        plt.show()


def compare_matrices(
    paths: List[Path],
    output_path: Optional[Path] = None
):
    """Compare multiple transfer matrices."""
    import matplotlib.pyplot as plt

    n = len(paths)
    fig, axes = plt.subplots(2, n, figsize=(5*n, 10))

    matrices = []
    for i, path in enumerate(paths):
        transfer, metadata = load_transfer_data(path)
        matrices.append(transfer)

        # Plot matrix
        ax = axes[0, i] if n > 1 else axes[0]
        data = np.log10(np.abs(transfer) + 1e-10)
        im = ax.imshow(data, cmap='viridis', aspect='equal')
        ax.set_title(path.stem, fontsize=10)
        ax.set_xlabel("Incident")
        ax.set_ylabel("Exitant")

        # Plot column sums
        ax = axes[1, i] if n > 1 else axes[1]
        col_sums = np.abs(transfer).sum(axis=0)
        ax.plot(col_sums, linewidth=0.5)
        ax.set_xlabel("Incident condition")
        ax.set_ylabel("Column sum")
        ax.set_title(f"Mean: {col_sums.mean():.4f}")

    plt.suptitle("Transfer Matrix Comparison")
    plt.tight_layout()

    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved to {output_path}")
        plt.close()
    else:
        plt.show()

    # Print numerical comparison
    if len(matrices) == 2:
        diff = np.abs(matrices[0] - matrices[1])
        print(f"\nMatrix difference statistics:")
        print(f"  Max absolute difference: {diff.max():.6e}")
        print(f"  Mean absolute difference: {diff.mean():.6e}")
        print(f"  Frobenius norm of difference: {np.linalg.norm(diff):.6e}")


def analyze_dataset(dataset_dir: Path, output_dir: Optional[Path] = None):
    """Analyze all transfer matrices in a dataset directory."""
    import matplotlib.pyplot as plt

    # Find all transfer files
    transfer_files = sorted(dataset_dir.glob("*_transfer.npz"))
    if not transfer_files:
        print(f"No transfer files found in {dataset_dir}")
        return

    print(f"Found {len(transfer_files)} transfer matrices")

    # Load metadata
    metadata_path = dataset_dir / 'metadata.json'
    if metadata_path.exists():
        with open(metadata_path) as f:
            dataset_meta = json.load(f)
        print(f"\nDataset metadata:")
        print(f"  Optical properties: sigma_s={dataset_meta['optical_properties']['sigma_s']}, "
              f"sigma_a={dataset_meta['optical_properties']['sigma_a']}, "
              f"g={dataset_meta['optical_properties']['g']}")
        print(f"  Discretization: {dataset_meta['discretization']['n_patches']} patches, "
              f"{dataset_meta['discretization']['n_sh']} SH coeffs")

    # Collect statistics
    stats = {
        'max_values': [],
        'mean_values': [],
        'col_sum_means': [],
        'nnz_ratios': [],
        'names': []
    }

    for tf in transfer_files:
        transfer, _ = load_transfer_data(tf)
        stats['max_values'].append(np.abs(transfer).max())
        stats['mean_values'].append(np.abs(transfer).mean())
        stats['col_sum_means'].append(np.abs(transfer).sum(axis=0).mean())
        stats['nnz_ratios'].append((transfer != 0).sum() / transfer.size)
        stats['names'].append(tf.stem.replace('_transfer', ''))

    # Plot statistics
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))

    ax = axes[0, 0]
    ax.bar(range(len(stats['max_values'])), stats['max_values'], alpha=0.7)
    ax.set_xlabel("Structure index")
    ax.set_ylabel("Max |T| value")
    ax.set_title("Maximum Transfer Values")

    ax = axes[0, 1]
    ax.bar(range(len(stats['mean_values'])), stats['mean_values'], alpha=0.7)
    ax.set_xlabel("Structure index")
    ax.set_ylabel("Mean |T| value")
    ax.set_title("Mean Transfer Values")

    ax = axes[1, 0]
    ax.bar(range(len(stats['col_sum_means'])), stats['col_sum_means'], alpha=0.7)
    ax.axhline(np.mean(stats['col_sum_means']), color='red', linestyle='--')
    ax.set_xlabel("Structure index")
    ax.set_ylabel("Mean column sum")
    ax.set_title("Energy Conservation (mean column sum)")

    ax = axes[1, 1]
    ax.bar(range(len(stats['nnz_ratios'])), np.array(stats['nnz_ratios']) * 100, alpha=0.7)
    ax.set_xlabel("Structure index")
    ax.set_ylabel("Non-zero ratio (%)")
    ax.set_title("Matrix Density")

    plt.suptitle(f"Dataset Analysis: {dataset_dir.name}\n({len(transfer_files)} structures)")
    plt.tight_layout()

    if output_dir:
        output_dir.mkdir(parents=True, exist_ok=True)
        plt.savefig(output_dir / 'dataset_analysis.png', dpi=150, bbox_inches='tight')
        print(f"Saved to {output_dir / 'dataset_analysis.png'}")
        plt.close()
    else:
        plt.show()

    # Print summary
    print(f"\nDataset Summary:")
    print(f"  Max transfer value: {np.max(stats['max_values']):.6e}")
    print(f"  Mean transfer value: {np.mean(stats['mean_values']):.6e}")
    print(f"  Mean energy conservation: {np.mean(stats['col_sum_means']):.4f}")
    print(f"  Mean density: {100*np.mean(stats['nnz_ratios']):.1f}%")


def interactive_explorer(path: Path):
    """Interactive exploration of transfer matrix using plotly."""
    try:
        import plotly.graph_objects as go
        from plotly.subplots import make_subplots
    except ImportError:
        print("Plotly required for interactive mode. Install with: pip install plotly")
        return

    transfer, metadata = load_transfer_data(path)

    # Create figure with subplots
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=('Transfer Matrix (log scale)', 'Column Sums',
                       'Face-to-Face Transport', 'Value Histogram'),
        specs=[[{'type': 'heatmap'}, {'type': 'scatter'}],
               [{'type': 'heatmap'}, {'type': 'histogram'}]]
    )

    # Transfer matrix heatmap
    data = np.log10(np.abs(transfer) + 1e-10)
    fig.add_trace(
        go.Heatmap(z=data, colorscale='Viridis', name='Transfer Matrix'),
        row=1, col=1
    )

    # Column sums
    col_sums = np.abs(transfer).sum(axis=0)
    fig.add_trace(
        go.Scatter(y=col_sums, mode='lines', name='Column Sums'),
        row=1, col=2
    )

    # Face-to-face transport
    n_sh = metadata.get('n_sh', 9)
    patches_per_face = metadata.get('patches_per_face', 8)
    n_per_face = patches_per_face ** 2 * n_sh

    if n_per_face * 6 == transfer.shape[0]:
        face_transport = np.zeros((6, 6))
        for i_face in range(6):
            for o_face in range(6):
                i_start = i_face * n_per_face
                i_end = (i_face + 1) * n_per_face
                o_start = o_face * n_per_face
                o_end = (o_face + 1) * n_per_face
                face_transport[o_face, i_face] = np.abs(transfer[o_start:o_end, i_start:i_end]).sum()

        face_names = ['+X', '-X', '+Y', '-Y', '+Z', '-Z']
        fig.add_trace(
            go.Heatmap(z=face_transport, x=face_names, y=face_names,
                      colorscale='YlOrRd', name='Face Transport'),
            row=2, col=1
        )

    # Value histogram
    values = transfer.flatten()
    values = values[values != 0]
    if len(values) > 0:
        fig.add_trace(
            go.Histogram(x=np.log10(np.abs(values) + 1e-10), nbinsx=50, name='Values'),
            row=2, col=2
        )

    fig.update_layout(
        title=f"Transfer Matrix Explorer: {path.stem}",
        height=800,
        showlegend=False
    )

    fig.show()


def cmd_matrix(args):
    """Handle 'matrix' subcommand."""
    path = Path(args.file)
    if not path.exists():
        print(f"File not found: {path}")
        return 1

    transfer, metadata = load_transfer_data(path)

    print(f"Transfer matrix: {path.name}")
    print(f"  Shape: {transfer.shape}")
    print(f"  Non-zero: {(transfer != 0).sum()} ({100*(transfer != 0).sum()/transfer.size:.1f}%)")
    print(f"  Range: [{transfer.min():.6e}, {transfer.max():.6e}]")
    print(f"  Mean column sum: {np.abs(transfer).sum(axis=0).mean():.4f}")

    output = Path(args.output) if args.output else None

    if args.stats:
        plot_transfer_statistics(transfer, metadata, output)
    elif args.faces:
        plot_face_to_face_transport(transfer, metadata, output)
    elif args.sh:
        plot_sh_mode_transport(transfer, metadata, output)
    else:
        plot_transfer_matrix(
            transfer,
            title=path.stem,
            output_path=output,
            log_scale=not args.linear,
            cmap=args.cmap
        )

    return 0


def cmd_compare(args):
    """Handle 'compare' subcommand."""
    paths = [Path(f) for f in args.files]
    for p in paths:
        if not p.exists():
            print(f"File not found: {p}")
            return 1

    output = Path(args.output) if args.output else None
    compare_matrices(paths, output)
    return 0


def cmd_analyze(args):
    """Handle 'analyze' subcommand."""
    dataset_dir = Path(args.directory)
    if not dataset_dir.exists():
        print(f"Directory not found: {dataset_dir}")
        return 1

    output = Path(args.output) if args.output else None
    analyze_dataset(dataset_dir, output)
    return 0


def cmd_interactive(args):
    """Handle 'interactive' subcommand."""
    path = Path(args.file)
    if not path.exists():
        print(f"File not found: {path}")
        return 1

    interactive_explorer(path)
    return 0


def main():
    parser = argparse.ArgumentParser(
        description="Visualize light transport ground truth datasets",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # Matrix visualization
    p_matrix = subparsers.add_parser('matrix', help='Visualize a single transfer matrix')
    p_matrix.add_argument('file', help='Path to transfer matrix .npz file')
    p_matrix.add_argument('-o', '--output', help='Save to file instead of displaying')
    p_matrix.add_argument('--linear', action='store_true', help='Use linear scale (default: log)')
    p_matrix.add_argument('--cmap', default='viridis', help='Colormap (default: viridis)')
    p_matrix.add_argument('--stats', action='store_true', help='Show statistics plots')
    p_matrix.add_argument('--faces', action='store_true', help='Show face-to-face transport')
    p_matrix.add_argument('--sh', action='store_true', help='Show SH mode coupling')
    p_matrix.set_defaults(func=cmd_matrix)

    # Compare matrices
    p_compare = subparsers.add_parser('compare', help='Compare multiple transfer matrices')
    p_compare.add_argument('files', nargs='+', help='Paths to transfer matrix files')
    p_compare.add_argument('-o', '--output', help='Save to file instead of displaying')
    p_compare.set_defaults(func=cmd_compare)

    # Analyze dataset
    p_analyze = subparsers.add_parser('analyze', help='Analyze a dataset directory')
    p_analyze.add_argument('directory', help='Path to dataset directory')
    p_analyze.add_argument('-o', '--output', help='Output directory for plots')
    p_analyze.set_defaults(func=cmd_analyze)

    # Interactive explorer
    p_interactive = subparsers.add_parser('interactive', help='Interactive exploration (plotly)')
    p_interactive.add_argument('file', help='Path to transfer matrix .npz file')
    p_interactive.set_defaults(func=cmd_interactive)

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        return 1

    return args.func(args)


if __name__ == '__main__':
    sys.exit(main())
